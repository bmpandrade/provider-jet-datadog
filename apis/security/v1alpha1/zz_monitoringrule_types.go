/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AgentRuleObservation struct {
}

type AgentRuleParameters struct {

	// **Deprecated**. It won't be applied anymore.
	// +kubebuilder:validation:Required
	AgentRuleID *string `json:"agentRuleId" tf:"agent_rule_id,omitempty"`

	// **Deprecated**. It won't be applied anymore.
	// +kubebuilder:validation:Required
	Expression *string `json:"expression" tf:"expression,omitempty"`
}

type MonitoringRuleCaseObservation struct {
}

type MonitoringRuleCaseParameters struct {

	// A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated based on the event counts in the previously defined queries.
	// +kubebuilder:validation:Optional
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// Name of the case.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Notification targets for each rule case.
	// +kubebuilder:validation:Optional
	Notifications []*string `json:"notifications,omitempty" tf:"notifications,omitempty"`

	// Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
	// +kubebuilder:validation:Required
	Status *string `json:"status" tf:"status,omitempty"`
}

type MonitoringRuleFilterObservation struct {
}

type MonitoringRuleFilterParameters struct {

	// The type of filtering action. Valid values are `require`, `suppress`.
	// +kubebuilder:validation:Required
	Action *string `json:"action" tf:"action,omitempty"`

	// Query for selecting logs to apply the filtering action.
	// +kubebuilder:validation:Required
	Query *string `json:"query" tf:"query,omitempty"`
}

type MonitoringRuleObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type MonitoringRuleParameters struct {

	// Cases for generating signals.
	// +kubebuilder:validation:Required
	Case []MonitoringRuleCaseParameters `json:"case" tf:"case,omitempty"`

	// Whether the rule is enabled.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Additional queries to filter matched events before they are processed.
	// +kubebuilder:validation:Optional
	Filter []MonitoringRuleFilterParameters `json:"filter,omitempty" tf:"filter,omitempty"`

	// Whether the notifications include the triggering group-by values in their title.
	// +kubebuilder:validation:Optional
	HasExtendedTitle *bool `json:"hasExtendedTitle,omitempty" tf:"has_extended_title,omitempty"`

	// Message for generated signals.
	// +kubebuilder:validation:Required
	Message *string `json:"message" tf:"message,omitempty"`

	// Options on rules.
	// +kubebuilder:validation:Optional
	Options []OptionsParameters `json:"options,omitempty" tf:"options,omitempty"`

	// Queries for selecting logs which are part of the rule.
	// +kubebuilder:validation:Required
	Query []QueryParameters `json:"query" tf:"query,omitempty"`

	// Tags for generated signals.
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The rule type. Valid values are `log_detection`, `infrastructure_configuration`, `workload_security`, `cloud_configuration`.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type NewValueOptionsObservation struct {
}

type NewValueOptionsParameters struct {

	// The duration in days after which a learned value is forgotten. Valid values are `1`, `2`, `7`, `14`, `21`, `28`.
	// +kubebuilder:validation:Required
	ForgetAfter *float64 `json:"forgetAfter" tf:"forget_after,omitempty"`

	// The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned. Valid values are `0`, `1`, `7`.
	// +kubebuilder:validation:Required
	LearningDuration *float64 `json:"learningDuration" tf:"learning_duration,omitempty"`
}

type OptionsObservation struct {
}

type OptionsParameters struct {

	// The detection method. Valid values are `threshold`, `new_value`, `anomaly_detection`.
	// +kubebuilder:validation:Optional
	DetectionMethod *string `json:"detectionMethod,omitempty" tf:"detection_method,omitempty"`

	// A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`.
	// +kubebuilder:validation:Required
	EvaluationWindow *float64 `json:"evaluationWindow" tf:"evaluation_window,omitempty"`

	// Once a signal is generated, the signal will remain “open” if a case is matched at least once within this keep alive window. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`.
	// +kubebuilder:validation:Required
	KeepAlive *float64 `json:"keepAlive" tf:"keep_alive,omitempty"`

	// A signal will “close” regardless of the query being matched once the time exceeds the maximum duration. This time is calculated from the first seen timestamp. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`, `43200`, `86400`.
	// +kubebuilder:validation:Required
	MaxSignalDuration *float64 `json:"maxSignalDuration" tf:"max_signal_duration,omitempty"`

	// New value rules specific options.
	// +kubebuilder:validation:Optional
	NewValueOptions []NewValueOptionsParameters `json:"newValueOptions,omitempty" tf:"new_value_options,omitempty"`
}

type QueryObservation struct {
}

type QueryParameters struct {

	// **Deprecated**. It won't be applied anymore. **Deprecated.** `agent_rule` has been deprecated in favor of new Agent Rule resource.
	// +kubebuilder:validation:Optional
	AgentRule []AgentRuleParameters `json:"agentRule,omitempty" tf:"agent_rule,omitempty"`

	// The aggregation type. Valid values are `count`, `cardinality`, `sum`, `max`, `new_value`.
	// +kubebuilder:validation:Optional
	Aggregation *string `json:"aggregation,omitempty" tf:"aggregation,omitempty"`

	// Field for which the cardinality is measured. Sent as an array.
	// +kubebuilder:validation:Optional
	DistinctFields []*string `json:"distinctFields,omitempty" tf:"distinct_fields,omitempty"`

	// Fields to group by.
	// +kubebuilder:validation:Optional
	GroupByFields []*string `json:"groupByFields,omitempty" tf:"group_by_fields,omitempty"`

	// The target field to aggregate over when using the sum or max aggregations.
	// +kubebuilder:validation:Optional
	Metric *string `json:"metric,omitempty" tf:"metric,omitempty"`

	// Name of the query.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Query to run on logs.
	// +kubebuilder:validation:Required
	Query *string `json:"query" tf:"query,omitempty"`
}

// MonitoringRuleSpec defines the desired state of MonitoringRule
type MonitoringRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MonitoringRuleParameters `json:"forProvider"`
}

// MonitoringRuleStatus defines the observed state of MonitoringRule.
type MonitoringRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MonitoringRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MonitoringRule is the Schema for the MonitoringRules API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,datadogjet}
type MonitoringRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MonitoringRuleSpec   `json:"spec"`
	Status            MonitoringRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MonitoringRuleList contains a list of MonitoringRules
type MonitoringRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MonitoringRule `json:"items"`
}

// Repository type metadata.
var (
	MonitoringRule_Kind             = "MonitoringRule"
	MonitoringRule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: MonitoringRule_Kind}.String()
	MonitoringRule_KindAPIVersion   = MonitoringRule_Kind + "." + CRDGroupVersion.String()
	MonitoringRule_GroupVersionKind = CRDGroupVersion.WithKind(MonitoringRule_Kind)
)

func init() {
	SchemeBuilder.Register(&MonitoringRule{}, &MonitoringRuleList{})
}
